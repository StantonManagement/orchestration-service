# <!-- Powered by BMADâ„¢ Core -->

# Story 1.1: Service Setup & Basic Health Endpoints

## Status

**Status:** Draft

## Story

**As a** developer,
**I want** to set up the basic FastAPI service structure with health endpoints and SMS reception,
**so that** the orchestrator can be monitored and receive incoming SMS data from the SMS Agent.

## Acceptance Criteria

1. FastAPI service is initialized with basic health check endpoint (`GET /health`)
2. POST `/orchestrate/sms-received` endpoint is implemented to receive SMS data
3. SMS data model validation is implemented for tenant_id, phone_number, content, and conversation_id
4. Basic logging and error handling for malformed SMS data
5. Service can be started and responds to both health and SMS endpoints
6. Basic health endpoint returns service status, version, and basic health indicators

## Tasks / Subtasks

- [ ] Create FastAPI application structure in app/main.py (AC: 1, 5)
  - [ ] Initialize FastAPI app with proper title and version
  - [ ] Configure CORS middleware for development
  - [ ] Set up application lifespan and startup/shutdown events
  - [ ] Include API routers for health and orchestration endpoints
- [ ] Implement health check endpoints in app/api/health.py (AC: 1, 6)
  - [ ] Create GET /health endpoint with basic service status
  - [ ] Add service version and uptime information
  - [ ] Return service status, version, and basic health indicators
- [ ] Create SMS reception endpoint in app/api/orchestration.py (AC: 2, 5)
  - [ ] Implement POST /orchestrate/sms-received endpoint
  - [ ] Add endpoint to main FastAPI router
- [ ] Create SMS data model in app/schemas/incoming_sms.py (AC: 3)
  - [ ] Create Pydantic model for IncomingSMS with validation
  - [ ] Include required fields: tenant_id, phone_number, content, conversation_id
  - [ ] Add field validation and type checking
- [ ] Implement basic error handling (AC: 4)
  - [ ] Add try/catch blocks for malformed SMS data
  - [ ] Return appropriate HTTP error codes (400, 500)
  - [ ] Add structured logging for errors
- [ ] Configure logging system in app/core/logging.py (AC: 4)
  - [ ] Set up structured logging with correlation IDs
  - [ ] Configure logging levels and output format
  - [ ] Add request ID tracking for traceability
- [ ] Create configuration management in app/config.py (AC: 5)
  - [ ] Set up environment variable handling with pydantic settings
  - [ ] Configure service version and other runtime settings
  - [ ] Add configuration validation
- [ ] Add basic application tests (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Test health endpoint returns correct status and structure
  - [ ] Test SMS endpoint accepts valid data and returns proper response
  - [ ] Test SMS endpoint rejects invalid data with appropriate errors
  - [ ] Test logging functionality captures errors properly

## Dev Notes

### Testing Standards
**Test file location:** `tests/test_api/test_health.py` and `tests/test_api/test_orchestration.py`
**Test standards:** pytest 7.4+ with pytest-asyncio, 80% coverage for critical paths [Source: architecture/test-strategy-and-standards.md#Test-Types-and-Organization]
**Testing frameworks and patterns:**
- Use pytest-mock for external dependencies
- Follow AAA pattern (Arrange, Act, Assert)
- Mock all external dependencies
- Test both success and error scenarios

### Source Tree Information
**Files to create/modify based on source tree:**
- `app/main.py` - FastAPI application entry point [Source: architecture/source-tree.md#7]
- `app/api/health.py` - Health check endpoints [Source: architecture/source-tree.md#26]
- `app/api/orchestration.py` - Main SMS processing endpoints [Source: architecture/source-tree.md#27]
- `app/schemas/incoming_sms.py` - IncomingSMS request schema [Source: architecture/source-tree.md#19]
- `app/core/logging.py` - Structured logging setup [Source: architecture/source-tree.md#47]
- `app/core/exceptions.py` - Custom exception classes [Source: architecture/source-tree.md#46]

### Technical Implementation Details

**Data Models:**
- Use Pydantic for request validation as specified in coding standards [Source: architecture/coding-standards.md#21]
- Required fields: tenant_id (string), phone_number (string), content (string), conversation_id (string, UUID format) [Source: architecture/rest-api-spec.md#68-82]

**API Specifications:**
- GET /health: Returns status (string), version (string) [Source: architecture/rest-api-spec.md#27-34]
- POST /orchestrate/sms-received: Expects JSON with required fields, returns processed status with workflow_id [Source: architecture/rest-api-spec.md#58-103]
- Response format must follow ApiResponse wrapper for consistency [Source: architecture/coding-standards.md#26]

**Tech Stack Constraints:**
- FastAPI 0.104+ with Python 3.11+ [Source: architecture/tech-stack.md#12-13]
- Use black formatting and ruff linting [Source: architecture/coding-standards.md#5]
- Use structured logging with correlation IDs - no console.log in production [Source: architecture/coding-standards.md#20]

**File Locations:**
- New code should be created in the existing app/ directory structure
- Tests should mirror app/ structure in tests/ directory [Source: architecture/test-strategy-and-standards.md#13]
- Use snake_case for files and functions, PascalCase for classes [Source: architecture/coding-standards.md#14]

### Previous Story Insights
This is the first story in Epic 1, so there are no previous story insights to consider.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story draft created from Epic 1.1 requirements | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List

## QA Results

### QA Agent Notes