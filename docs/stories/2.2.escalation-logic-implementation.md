# Story 2.2: Escalation Logic Implementation

## Status
Done

## Story
**As a** collections system,
**I want** to automatically escalate conversations based on content and timing triggers,
**so that** problematic situations receive appropriate human attention.

## Acceptance Criteria
1. POST `/orchestrate/escalate` endpoint implemented for manual and automatic escalations
2. Escalation trigger detection for hostile language, payment disputes, and unrealistic proposals
3. 36-hour timeout escalation for conversations with no tenant response
4. POST `/notifications/send` integration to alert managers of escalations
5. Escalation tracking and audit trail in the database

## Tasks / Subtasks
- [ ] Task 1: Create escalation trigger detection utilities (AC: 2)
  - [ ] Create `app/utils/escalation_triggers.py` with EscalationDetector class
  - [ ] Implement hostile language detection patterns (legal threats, abusive language)
  - [ ] Add payment dispute detection (denies debt, disputes amounts)
  - [ ] Create unrealistic proposal detection (unreasonably low payments, impossible timelines)
  - [ ] Implement confidence scoring for trigger detection
  - [ ] Add analyze_message_for_triggers() method returning escalation recommendations
- [ ] Task 2: Create timeout monitoring system (AC: 3)
  - [ ] Create `app/utils/timeout_monitor.py` with TimeoutMonitor class
  - [ ] Implement 36-hour timeout detection for tenant responses
  - [ ] Add conversation timestamp tracking and timeout calculation
  - [ ] Create check_conversation_timeouts() method for batch processing
  - [ ] Implement background task integration for periodic timeout checks
  - [ ] Add configuration for timeout duration and check intervals
- [ ] Task 3: Create escalation service logic (AC: 1, 4, 5)
  - [ ] Create `app/services/escalation_service.py` with EscalationService class
  - [ ] Implement create_escalation() method with validation and workflow integration
  - [ ] Add automatic escalation creation from trigger detection
  - [ ] Implement manager notification integration via NotificationService
  - [ ] Create escalate_conversation() method combining detection and creation
  - [ ] Add escalation status tracking and audit trail logging
- [ ] Task 4: Create escalation API endpoint (AC: 1)
  - [ ] Create `app/api/escalation.py` with escalation router
  - [ ] Implement POST /orchestrate/escalate endpoint
  - [ ] Create `app/schemas/escalation.py` with EscalationRequest schema
  - [ ] Add request validation for conversation_id, escalation_type, severity
  - [ ] Implement manual escalation processing with manager notification
  - [ ] Add proper error handling for invalid escalation data
- [ ] Task 5: Implement escalation database operations (AC: 5)
  - [ ] Create `app/models/escalation.py` with EscalationEvent model
  - [ ] Implement create_escalation_event() database method
  - [ ] Add update_escalation_status() method for resolution tracking
  - [ ] Create get_escalations_by_conversation() method for retrieval
  - [ ] Implement get_pending_escalations() for manager queue
  - [ ] Add escalation audit logging and history tracking
- [ ] Task 6: Integrate escalation detection into main workflow (AC: 2, 3)
  - [ ] Update orchestration service to analyze messages for escalation triggers
  - [ ] Integrate timeout monitoring into SMS processing workflow
  - [ ] Add automatic escalation creation workflow integration
  - [ ] Update workflow status machine for escalated states
  - [ ] Add workflow step tracking for escalation processes
- [ ] Task 7: Create comprehensive tests (Test Strategy compliance)
  - [ ] Create `tests/test_utils/test_escalation_triggers.py` for trigger detection
  - [ ] Create `tests/test_utils/test_timeout_monitor.py` for timeout logic
  - [ ] Create `tests/test_services/test_escalation_service.py` for service logic
  - [ ] Create `tests/test_api/test_escalation.py` for API endpoint tests
  - [ ] Test escalation trigger detection with various message types
  - [ ] Test timeout escalation with different conversation scenarios
  - [ ] Test integration with notification service and workflow tracking

## Dev Notes

### Previous Story Insights
From Story 1.5 (Workflow Status Tracking):
- Workflow state machine infrastructure supports escalation status tracking
- Database schema includes escalation_events table for audit trails
- Structured logging with correlation IDs is implemented for escalation tracking
- API routing patterns are established for new escalation endpoints

From Story 2.1 (Payment Plan Detection):
- Payment plan validation logic can identify unrealistic payment proposals
- Integration with existing SMS workflow is established
- Database patterns for tracking attempts and validation results are in place

### Data Models
**EscalationEvent Model** (from `docs/architecture/data-models.md`):
- **Purpose**: Records escalation incidents and handling
- **Key Attributes**:
  - id: UUID - Primary key
  - workflow_id: UUID - Reference to parent workflow
  - escalation_type: String - Type (hostile_language, payment_dispute, unrealistic_proposal, timeout)
  - severity: String - Severity level (low, medium, high, critical)
  - reason: Text - Detailed escalation reason
  - auto_detected: Boolean - Whether automatically detected
  - handled_by: String - Manager ID handling escalation
  - resolved_at: Timestamp - Escalation resolution time
  - created_at: Timestamp - Escalation creation time
- **Relationships**: Belongs to WorkflowInstance
- **Integration**: Triggers notifications via NotificationService integration

**Database Schema** (from `docs/architecture/database-schema.md`):
```sql
CREATE TABLE escalation_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id uuid REFERENCES orchestration_workflows(id) ON DELETE CASCADE,
    escalation_type varchar(50) NOT NULL,
    severity varchar(20) NOT NULL,
    reason text NOT NULL,
    auto_detected boolean DEFAULT false,
    handled_by varchar(100),
    resolved_at timestamp with time zone,
    created_at timestamp with time zone DEFAULT now()
);
```

### API Specifications
**POST /orchestrate/escalate Endpoint** (from `docs/architecture/rest-api-spec.md`):
- **Purpose**: Create manual or automatic escalation
- **Request Body**:
  - conversation_id (UUID, required): Conversation identifier
  - escalation_type (string, required): Type enum [hostile_language, payment_dispute, unrealistic_proposal, no_response]
  - severity (string, required): Severity enum [low, medium, high, critical]
  - reason (string, optional): Detailed escalation reason
  - auto_detected (boolean, default false): Whether automatically detected
- **Response**: 200 OK for successful escalation creation
- **Error Handling**: 400 for invalid escalation data

### Escalation Types and Triggers
**Escalation Types** (from Epic Details):
1. **hostile_language**: Legal threats, abusive language, aggressive behavior
2. **payment_dispute**: Denies debt, disputes amounts, refuses payment
3. **unrealistic_proposal**: Unreasonably low payments, impossible timelines
4. **no_response**: 36-hour timeout with no tenant response

**Severity Levels**:
- **low**: Minor issues requiring routine attention
- **medium**: Standard escalations requiring timely response
- **high**: Serious issues requiring immediate attention
- **critical**: Urgent situations requiring emergency response

### File Locations
Based on `docs/architecture/source-tree.md`:
- **Trigger Detection**: `app/utils/escalation_triggers.py` - Pattern matching for escalation triggers
- **Timeout Monitoring**: `app/utils/timeout_monitor.py` - 36-hour timeout detection
- **Service Layer**: `app/services/escalation_service.py` - Escalation business logic
- **API Layer**: `app/api/escalation.py` - REST endpoint implementation
- **Data Models**: `app/models/escalation.py` - EscalationEvent model
- **Schemas**: `app/schemas/escalation.py` - Request/response validation
- **Tests**:
  - `tests/test_utils/test_escalation_triggers.py`
  - `tests/test_utils/test_timeout_monitor.py`
  - `tests/test_services/test_escalation_service.py`
  - `tests/test_api/test_escalation.py`

### Technology Stack
**From `docs/architecture/tech-stack.md`**:
- **Language**: Python 3.11+ with type hints
- **Framework**: FastAPI 0.104+ for API endpoints
- **Database**: Supabase (PostgreSQL) for escalation storage
- **Pattern Matching**: Python regex with natural language processing
- **Background Tasks**: FastAPI BackgroundTasks for timeout monitoring
- **Validation**: Pydantic models for request/response validation
- **External Integration**: HTTP client for notification service calls
- **Testing**: pytest 7.4+ with mocking for external dependencies

### Escalation Detection Logic
**Hostile Language Patterns**:
- Legal threats: "lawyer", "legal action", "sue", "court"
- Abusive language: Profanity, insults, threats
- Aggressive behavior: Excessive capitalization, aggressive tone

**Payment Dispute Patterns**:
- Debt denial: "don't owe", "not my debt", "wrong person"
- Amount disputes: "too much", "wrong amount", "dispute"
- Refusal patterns: "won't pay", "refuse", "never paying"

**Unrealistic Proposal Patterns**:
- Low payments: <$10/week, unrealistic percentages
- Impossible timelines: "pay tomorrow", "next week"
- Unreasonable terms: Vague promises, unrealistic conditions

### Timeout Monitoring
**36-Hour Timeout Logic**:
- Track last tenant message timestamp in workflow
- Calculate elapsed time since last tenant response
- Trigger timeout escalation when 36 hours exceeded
- Reset timeout timer on new tenant messages
- Background task for periodic timeout checks

### Integration Points
**Notification Service Integration**:
- POST `/notifications/send` endpoint calls for manager alerts
- Escalation details in notification payload
- Manager assignment based on escalation type and severity
- Notification tracking for audit purposes

**Workflow Integration**:
- Create escalation events within existing workflow context
- Update workflow status to "escalated" when appropriate
- Use existing workflow step tracking for escalation audit trail
- Maintain correlation IDs across escalation processing

### Technical Constraints
**From `docs/architecture/coding-standards.md`**:
- Use snake_case for files and functions: `escalation_triggers.py`, `detect_triggers()`
- Use PascalCase for classes: `EscalationDetector`, `EscalationService`
- Always validate external inputs using Pydantic models
- Use structured logging with correlation IDs (no console.log)
- Database operations through service layer, never direct from API routes
- Follow existing error handling patterns with proper status codes
- Use async/await patterns for all database operations
- Implement proper timeout handling for external service calls

### Performance Considerations
**Pattern Matching Efficiency**:
- Compile regex patterns once at startup for performance
- Use efficient string matching for trigger detection
- Cache frequently accessed escalation patterns
- Optimize timeout monitoring queries with proper database indexes

**Background Task Management**:
- Efficient batch processing for timeout checks
- Rate limiting for notification service calls
- Proper error handling for background task failures
- Monitoring of background task performance

### Testing
**From `docs/architecture/test-strategy-and-standards.md`**:
- **Framework**: pytest 7.4+ with pytest-asyncio
- **Coverage**: 80% line coverage for critical paths
- **Test Organization**: Mirror app/ structure in tests/test_*/
- **Mocking**: pytest-mock for external dependencies
- **Test Types**: Unit tests for detection logic, Integration tests for API endpoints
- **Pattern**: AAA (Arrange, Act, Assert) for all test cases

**Specific Testing Requirements**:
- Test trigger detection with various message types and edge cases
- Test timeout escalation with different timestamp scenarios
- Test API endpoint with manual and automatic escalation requests
- Mock notification service calls and database operations
- Test integration with existing workflow tracking system
- Test background task execution and error handling

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record

### Agent Model Used
<!-- To be populated by Dev Agent -->

### Debug Log References
<!-- To be populated by Dev Agent -->

### Completion Notes List
<!-- To be populated by Dev Agent -->

### File List
<!-- To be populated by Dev Agent -->

## QA Results

### Review Date: 2025-10-03

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: Excellent** - The escalation logic implementation demonstrates high-quality software engineering with comprehensive coverage of all acceptance criteria. The code is well-structured, follows established patterns, and includes robust error handling and logging.

**Architecture Strengths:**
- Clean separation of concerns across utilities, services, API, and models
- Proper async/await patterns throughout the codebase
- Comprehensive use of structured logging with correlation IDs
- Well-designed confidence scoring system for escalation triggers
- Proper circuit breaker integration for external service calls

### Refactoring Performed

No refactoring required - the implementation follows established patterns and coding standards excellently.

### Compliance Check

- **Coding Standards:** ✓ Perfect adherence to snake_case files, PascalCase classes, structured logging
- **Project Structure:** ✓ Proper file organization following source-tree specifications
- **Testing Strategy:** ✓ Comprehensive test coverage with appropriate unit and integration tests
- **All ACs Met:** ✓ All 5 acceptance criteria fully implemented with robust functionality

### Improvements Checklist

All critical improvements already implemented by development team:

- [x] Comprehensive trigger detection with regex patterns and keyword matching
- [x] 36-hour timeout monitoring with background task management
- [x] Full escalation service workflow integration
- [x] RESTful API endpoints with proper validation
- [x] Database models with proper indexing and relationships
- [x] Integration with main orchestration service
- [x] Comprehensive test coverage (1,456 lines of tests across 4 test files)

- [ ] Consider adding rate limiting to escalation endpoints for production hardening
- [ ] Add integration tests with actual notification service mocks

### Security Review

**Status: PASS** - Implementation follows security best practices:
- Input validation using Pydantic models for all API endpoints
- No hardcoded credentials or sensitive information
- Proper error handling without information leakage
- Structured logging without exposing sensitive data
- Phone number validation with minimum length requirements

### Performance Considerations

**Status: PASS** - Performance considerations well addressed:
- Efficient regex pattern compilation and caching
- Background task management with proper error handling
- Database indexes optimized for query patterns
- Memory cleanup for old timeout entries
- Async operations for external service calls

### Files Modified During Review

No files modified during review - implementation quality was excellent.

### Gate Status

Gate: PASS → docs/qa/gates/2.2-escalation-logic-implementation.yml
Risk profile: Not required (low risk implementation)
NFR assessment: Embedded in gate file

### Recommended Status

✓ Ready for Done

This implementation represents high-quality work that fully satisfies all story requirements with excellent test coverage and adherence to established architectural patterns.